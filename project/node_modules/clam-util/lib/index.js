"use strict";

var path = require('path'),
  http = require('http'),
  fs = require('fs-extra'),
  exec = require('child_process').exec,
  shell = require('shelljs'),
  mixinDeep = require('mixin-deep'),
  EOL = require('os').EOL,
  crypto = require('crypto');

var NORMAL_FILTERS = [];
var NORMAL_EXFILTERS = [/node_modules/i, /Gruntfile\.js$/i];
var GRUNT_TASK_DEFAULT_DIR = 'grunt/default',
  GRUNT_TASK_CUSTOM_DIR = 'grunt/custom';

// 遍历当前目录的文件
function doWalk(uri, files, filters, ex_filters) {

  var stat = fs.lstatSync(uri);
  if (stat.isFile() && doMatch(uri, filters, ex_filters)) {

    var ext = path.extname(uri).replace(/^\./i, '');
    if (typeof files[ext] === 'undefined') {
      files[ext] = [];
    }
    files[ext].push(uri.split(path.sep).join('/'));
  }
  if (stat.isDirectory()) {
    fs.readdirSync(uri).forEach(function (part) {
      doWalk(path.join(uri, part), files, filters, ex_filters);
    });
  }
}


// 得到文件结构的数据结构
// filters: [/rexg1/,/rexg2/]
function walk(rootDir, filters, ex_filters) {
  var files = {
    /*
     css: [],
     less: [],
     scss: [],
     js: [],
     other: [] // 暂时没用
     */
  };
  doWalk(rootDir, files, filters, ex_filters);
  for (var i in files) {
    files[i].forEach(function (v, k) {
      files[i][k] = v.replace(rootDir + '/', '');
    });
  }
  return files;
}

function doMatch(p, filters, ex_filters) {
  if (!filters instanceof Array) {
    return true;
  }
  if (!ex_filters instanceof Array) {
    ex_filters = [];
  }
  var flag = true;
  filters.forEach(function (v, k) {
    if (v.test && !v.test(p)) {
      flag = false;
    }
  });
  ex_filters.forEach(function (v, k) {
    if (v.test && v.test(p)) {
      flag = false;
    }
  });
  return flag;
}

// 得到最大的版本号
function getBiggestVersion(A) {
  var a = [];
  var b = [];
  var t = [];
  var r = [];
  if (!A) {
    return [0, 0, 0];
  }
  for (var i = 0; i < A.length; i++) {
    if (A[i].match(/^\d+\.\d+\.\d+$/)) {
      var sp = A[i].split('.');
      a.push([
        Number(sp[0]), Number(sp[1]), Number(sp[2])
      ]);
    }
  }

  var r = findMax(findMax(findMax(a, 0), 1), 2);
  return r[0];
}

// a：二维数组，index，比较第几个
// return：返回保留比较后的结果组成的二维数组
function findMax(a, index) {
  var t = [];
  var b = [];
  var r = [];
  for (var i = 0; i < a.length; i++) {
    t.push(Number(a[i][index]));
  }
  var max = Math.max.apply(this, t);
  for (var i = 0; i < a.length; i++) {
    if (a[i][index] === max) {
      b.push(i);
    }
  }
  for (var i = 0; i < b.length; i++) {
    r.push(a[b[i]]);
  }
  return r;
}

// h5-test => test/
// pad-test => test/pad/
// test => test/
function awppDirName(proName) {
  if (/^h5-([^\/]+)$/.test(proName)) {
    return proName.match(/^h5-([^\/]+)$/)[1];
  } else if (/^pad-([^\/]+)$/.test(proName)) {
    return proName.match(/^pad-([^\/]+)$/)[1] + '/pad';
  } else {
    return proName;
  }
}

function getBranchVersion(callback) {
  exec('git rev-parse --abbrev-ref HEAD', function (err, stdout, stderr, cb) {
    var reg = /daily\/(\S+)/,
      match = stdout.match(reg);

    if (!match) {
      console.log('当前分支为 master 或者名字不合法(daily/x.y.z)，建议切换到daily分支' +
        '\n创建新daily分支：grunt newbranch' +
        '\n只执行构建：grunt build');
      callback(stdout.trim());

    } else {
      /*
       grunt.log.write(('当前分支：' + match[1]).green);
       grunt.config.set('currentBranch', match[1]);
       */
      callback(match[1]);
    }
  });
}

//简单的模板替换
function sub(s, o) {
  return s.replace ? s.replace(/\{\s*([^|}]+?)\s*(?:\|([^}]*))?\s*\}/g, function (match, key) {
    return typeof o[key] === 'undefined' ? match : o[key];
  }) : s;
}

/**
 * 计算两个 sha（分支、tag）之间的差异文件
 * @param sha1 {String}
 * @param sha2 {String}
 * @param dir {String} 指定目录，默认 '.'
 * @returns {Object}
 *  {
 *    add: ['xxx', 'xxx'],
 *    update: ['xxx', 'xxx'],
 *    delete: []
 *  }
 */
function calcDiffFiles(sha1, sha2, dir) {
  dir = dir || '.';
  var cmd = 'git diff --name-status --no-color ' + sha1 + ' ' + sha2 + ' ' + dir;
  var result = shell.exec(cmd, {
    silent: false
  });
  if (result.code == 0) {
    var output = result.output;
    var lines = output.trim().split(EOL);
    var map = {
      'add': [],
      'update': [],
      'delete': []
    };
    lines.forEach(function (line) {
      line = line.trim();
      if (line != '') {
        line = line.split('\t');
        line[1] = path.relative(dir, line[1]);
        switch (line[0]) {
          case 'M':
            map.update.push(line[1]);
            break;
          case 'D':
            map.delete.push(line[1]);
            break;
          case 'A':
            map.add.push(line[1]);
            break;
          default:
            break;
        }
      }
    });
    map.hasUpdate = (map.add.length > 0) || (map.update.length > 0) || (map.delete.length > 0);
    return map;
  } else {
    console.error(result);
    return null;
  }
}

function paddingVersionDigit(version, versionLength, digits) {
  while (versionLength++ < digits) {
    version.push('0');
  }
  return version;
}

/**
 * 比较两个语义化版本号
 * @param versionA {String}
 * @param versionB {String}
 * @param sep {String} 版本号分隔符，默认 "."
 * @returns {Number} -1 / 0 / 1
 */
function compareSemver(versionA, versionB, sep) {
  sep = sep || '.';
  versionA = versionA.split(sep);
  versionB = versionB.split(sep);
  if (versionA.length == versionB.length) {

    var digitLength = versionA.length,
      ret = 0;
    for (var i = 0; i < digitLength; i++) {
      var vAi = versionA[i],
        vBi = versionB[i],
        diff = vAi - vBi;
      if (diff != 0) {
        ret = diff / Math.abs(diff);
        break;
      }
    }

    return ret;

  } else {
    // 位数不一致，补全 0
    var vAlength = versionA.length,
      vBlength = versionB.length,
      maxVersionLength = Math.max(vAlength, vBlength);

    (vAlength != maxVersionLength) && (versionA = paddingVersionDigit(versionA, vAlength, maxVersionLength));
    (vBlength != maxVersionLength) && (versionB = paddingVersionDigit(versionB, vBlength, maxVersionLength));
    return compareSemver(versionA.join(sep), versionB.join(sep));
  }
}

/**
 * 找出一组语义化版本号中的 Top N
 * @param versions {Array} 版本号字符串数组
 * @param N {Number} Top N
 * @returns {Array} Top N 项
 */
function calcTopNVersions(versions, N) {
  versions.sort(compareSemver).reverse();
  return versions.slice(0, N);
}

/**
 * 从指定目录加载 grunt 任务配置项
 * @param taskDir {String} 任务配置目录
 * @param abcConfig {Object} abc.json 中配置
 * @param customConfig {Object} 自定义任务配置
 * @param grunt {Object} grunt
 * @returns {Object} 以任务名为键，任务配置对象为值的键值对
 */
function loadTaskConfig(taskDir, abcConfig, customConfig, grunt) {
  var retObj = {};

  // 如果 taskDir 不是以 '/' 开头的绝对路径, 先拼接上 process.cwd()
  if (!/^\//.test(taskDir)) {
    taskDir = path.join(process.cwd(), taskDir);
  }

  // 任务目录不存在
  if (!fs.existsSync(taskDir)) {
    return retObj;
  }

  fs.readdirSync(taskDir).forEach(function (taskConfigFile) {
    if (/\.js$/.test(taskConfigFile)) {
      var taskName = taskConfigFile.split('.')[0];

      var taskExport = require(path.join(taskDir, taskConfigFile));
      retObj[taskName] = (typeof taskExport == 'function') ? taskExport(abcConfig, grunt, customConfig[taskName] || {}) : taskExport;
    }
  });
  return retObj;
}

/**
 * 合并默认和自定义的各个 grunt 任务配置
 * @param abcConfig {Object} abc.json 配置
 * @param grunt {Object} grunt
 * @param defaultTaskDir {String} 默认任务配置所在目录
 * @param customTaskDir {String} 自定义任务配置所在目录
 * @returns {Object} 合并成的最终的 grunt 任务配置
 */
function loadGruntConfig(abcConfig, grunt, defaultTaskDir, customTaskDir) {
  var customConfig = loadTaskConfig(customTaskDir || GRUNT_TASK_CUSTOM_DIR, abcConfig, {}, grunt);
  var defaultConfig = loadTaskConfig(defaultTaskDir || GRUNT_TASK_DEFAULT_DIR, abcConfig, customConfig, grunt);
  return mixinDeep(defaultConfig, customConfig);
}

/**
 * [For New Clam]合并默认和自定义的各个 grunt 任务配置
 * @param abcConfig {Object} abc.json 配置
 * @param grunt {Object} grunt
 * @param gruntDefaultConfigMap {Object} 默认任务配置 map
 * @param gruntCustomConfigDir {String} 自定义任务 js 所在 dir
 * @returns {Object} 合并成的最终的 grunt 任务配置
 */
exports.mergeGruntConfig = function (abcConfig, grunt, gruntDefaultConfigMap, gruntCustomConfigDir) {
  var defaultConfig = {};
  var customConfig = loadTaskConfig(gruntCustomConfigDir || 'grunt', abcConfig, {}, grunt);
  Object.keys(gruntDefaultConfigMap).forEach(function (taskName) {
    var taskExport = gruntDefaultConfigMap[taskName];
    defaultConfig[taskName] = (typeof taskExport == 'function') ? taskExport(abcConfig, grunt, customConfig[taskName]) : taskExport;
  });
  return mixinDeep(defaultConfig, customConfig);
};

/**
 * 获取当前 Git 仓库的所有 tag
 * @returns {Null|Array}
 */
function getGitTags() {
  var result = shell.exec('git tag -l', {silent: true});
  if (result.code != 0) {
    console.error(result);
    return null;
  } else {
    var output = result.output.trim();
    if (output === '') {
      return null;
    } else {
      return output.split(EOL);
    }
  }
}

function waitUntilUrlAvailable(url, callback) {

  var MAX_RETRY_TIME = 10;

  var retryTime = 0;
  var timer = setInterval(function () {

    if (retryTime >= MAX_RETRY_TIME) {
      clearInterval(timer);
      callback(false);
    } else {

      http.get(url, function (res) {
        if (res.statusCode == 200) {
          clearInterval(timer);
          callback(true);
        }
      }).on('error', function (e) {
        console.error('HTTP CHECK URL ' + url + ' error: ' + e.message);
        clearInterval(timer);
        callback(false);
      });
    }
    retryTime++;
  }, 2000);
}

function stablizeObject(obj) {
  var ret = {};
  if (obj && typeof obj === 'object') {
    if (Array.isArray(obj)) {
      ret = obj.sort();
    } else {
      var sortedKeys = Object.keys(obj).sort();
      sortedKeys.forEach(function (sKey) {
        ret[sKey] = stablizeObject(obj[sKey]);
      });
    }
  } else {
    ret = obj;
  }
  return ret;
}

if (!fs.writeJSONFile) {
  fs.writeJSONFile = fs.outputJson ? function (file, data, callback) {
    fs.outputJson(file, data, {spaces: 2}, callback);
  } : function (file, data, callback) {
    fs.writeFile(file, JSON.stringify(data, null, 2), callback);
  };
} else {
  var origWriteJSONFile = fs.writeJSONFile;
  fs.writeJSONFile = function (file, data, callback) {
    origWriteJSONFile(file, data, {spaces: 2}, callback);
  };
}

function md5 (text) {
  return crypto.createHash('md5').update(text).digest('hex');
}

/**
 * 从 bower.json & package.json 中解析依赖, 生成 webpack external map
 * @returns {{}}
 */
exports.parseDepMap = function () {
  var pwd = process.cwd();
  var depArr = [];
  var bowerConfig = {}, pkgConfig = {};
  try {
    bowerConfig = require(path.join(pwd, './bower.json'));
    pkgConfig = require(path.join(pwd, './package.json'));
  } catch (e) {}
  depArr = depArr
    .concat(Object.keys(bowerConfig.dependencies || []))
    .concat(Object.keys(pkgConfig.dependencies || []));
  var ret = {};
  depArr.forEach(function (dep) {
    ret[dep] = dep;
  });
  return ret;
};

exports.sub = sub;
exports.awppDirName = awppDirName;
exports.fs = fs;
exports.walk = walk;
exports.findMax = findMax;
exports.getBiggestVersion = getBiggestVersion;
exports.getBranchVersion = getBranchVersion;
exports.NORMAL_FILTERS = NORMAL_FILTERS;
exports.NORMAL_EXFILTERS = NORMAL_EXFILTERS;
exports.loadGruntConfig = loadGruntConfig;
exports.calcDiffFiles = calcDiffFiles;
exports.compareSemver = compareSemver;
exports.calcTopNVersions = calcTopNVersions;
exports.getGitTags = getGitTags;
exports.waitUntilUrlAvailable = waitUntilUrlAvailable;
exports.stablizeObject = stablizeObject;
exports.md5 = md5;