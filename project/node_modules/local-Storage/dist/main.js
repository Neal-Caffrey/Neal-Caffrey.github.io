(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;/*
* Storage - 1.0.0
*
* options [选填] js对象。
* {
***   exp:   100,类型Number。超时时间，秒。默认无限大。
***   force: true,可删除
***   sign : 前缀Storage_,标示可自定义，
***   value: [必填] 支持所有可以JSON.parse 的类型。注：当为undefined的时候会执行 delete(key)操作。
* }
*/


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _gol = window || undefined;

var _ref = [_gol.localStorage, _gol.document],
    _storage = _ref[0],
    _doc = _ref[1];

var _maxExpireDate = new Date('Fri, 31 Dec 9999 23:59:59 UTC');

var _defaultExpire = _maxExpireDate;
var _defaultSerializer = {
    serialize: function serialize(item) {
        return JSON.stringify(item);
    },
    deserialize: function deserialize(data) {
        return data && JSON.parse(data);
    },
    deepParse: function deepParse(obj) {
        var _this2 = this;

        obj = this.deserialize(obj);
        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' && obj.map) return obj.map(function (v, k) {
            return _this2.deserialize(v);
        });
        return [].concat(this.deserialize(obj));
    }
};

var _extend = function _extend(obj, props) {
    for (var key in props) {
        obj[key] = props[key];
    }return obj;
};

var _isValidDate = function _isValidDate(date) {
    return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
};

var _getExpiresDate = function _getExpiresDate(expires, now) {
    now = now || new Date();
    if (typeof expires === 'number') {
        expires = expires === Infinity ? _maxExpireDate : new Date(now.getTime() + expires * 1000);
    } else if (typeof expires === 'string') {
        expires = new Date(expires);
    }
    if (expires && !_isValidDate(expires)) {
        throw new Error('`expires` parameter cannot be converted to a valid Date instance');
    }

    return expires;
};

var _removeItem = function _removeItem(item, key, val, ikey) {
    var newItem = [].concat(item);
    var dx = _checkIndexOf(newItem, key, ikey);

    if (dx > -1) {
        if (val) newItem.splice(dx, 1).splice(dx, 0, val);else newItem.splice(dx, 1);
        return newItem;
    } else return newItem;
};

var _isQuotaExceeded = function _isQuotaExceeded(e) {
    //超过大小
    var quotaExceeded = false;
    if (e) {
        if (e.code) {
            switch (e.code) {
                case 22:
                    quotaExceeded = true;
                    break;
                case 1014:
                    if (e.name === 'NS_ERROR_DOM_QUOTA_REACHED') quotaExceeded = true;
                    break;
            }
        } else if (e.number === -2147024882) {
            quotaExceeded = true;
        }
    }
    return quotaExceeded;
};
var _isCacheItem = function _isCacheItem(item) {
    if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') return false;
    if (item) if ('c' in item && 'e' in item && 'v' in item) return true;
    return false;
};

var _checkCacheItemIfEffective = function _checkCacheItemIfEffective(cacheItem) {
    return new Date().getTime() < cacheItem.e;
};

var _checkAndWrapKeyAsString = function _checkAndWrapKeyAsString(key) {
    if (typeof key !== 'string') {
        console.warn('key used as a key, but get `${key}`');
        key = String(key);
    }
    return key;
};

var _checkIndexOf = function _checkIndexOf(checks, val, key) {
    var result = false;

    var arr = [].concat(checks);

    for (var i = 0, len = arr.length; i < len; i++) {
        if (key) {
            if (JSON.parse(arr[i])[key] == JSON.parse(val)[key]) {
                result = i;
                break;
            } else result = -1;
        } else {
            if (arr[i] == val) {
                result = i;
                break;
            } else result = -1;
        }
    }
    return result;
};

var _checkCacheName = function _checkCacheName(name, sign) {
    return name.indexOf(sign) > -1;
};
var _getRealName = function _getRealName(key, sign) {
    return _checkCacheName(key, sign) ? key : sign + key;
};

var CacheItemConstructor = function CacheItemConstructor(value, ops) {
    _classCallCheck(this, CacheItemConstructor);

    var exp = ops.exp || _defaultExpire;
    var expires = _getExpiresDate(exp);
    this.c = new Date().getTime();
    this.e = expires.getTime();
    this.v = value;
    this.p = ops.path || '/';
    this.d = ops.domain;
};

;

var Storage = function () {
    function Storage(options) {
        _classCallCheck(this, Storage);

        this.isSupported = _storage;
        this._init(options);
    }

    _createClass(Storage, [{
        key: '_init',
        value: function _init(options) {
            var defaults = {
                storage: 'localStorage',
                exp: Infinity,
                sign: 'Storage_'
            };

            var opt = _extend(defaults, options);

            var expires = opt.exp;

            if (expires && typeof expires !== 'number' && !_isValidDate(expires)) throw new Error('exp used a Date or number or noop but get `${expires}`');else _defaultExpire = expires;

            this._sign = opt.sign;

            if (this.isSupported) this._checkList(_storage);

            if (!this.isSupported && !_doc['cookie']) {
                _extend(this, this._cacheApi());
                console.error('need open locationStorage or cookie, please check your browser');
            }
        }
    }, {
        key: '_checkList',
        value: function _checkList(item) {
            if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') return false;
            for (var name in item) {
                if (_checkCacheName(name, this._sign)) {
                    var cacheItem = _checkCacheItemIfEffective(_defaultSerializer.deserialize(item[name]));
                    if (!cacheItem) this.delete(name);
                }
            }
        }
    }, {
        key: '_quotaExceedHandler',
        value: function _quotaExceedHandler(key, val, options, e) {
            if (options && options.force === true) {
                var deleteKeys = this.deleteAll();
                console.warn('delete all expires CacheItem : [`${deleteKeys}`] and try execute `set` method again!');
                try {
                    options.force = false;
                    this.set(key, val, options);
                } catch (err) {
                    console.warn('set localstorage failed, error is : %s', err);
                }
            }
        }
    }, {
        key: '_cacheApi',
        value: function _cacheApi() {
            return {
                set: function set(key, value, options) {},
                get: function get(key, deep) {},
                delete: function _delete(key) {},
                deleteAll: function deleteAll() {},
                add: function add(key, options) {},
                replace: function replace(key, value, options) {},
                clear: function clear() {}
            };
        }
    }, {
        key: '_setCookie',
        value: function _setCookie(key, val, item) {
            var cookieStr = '',
                nDays = new Date();
            cookieStr += key + '=' + encodeURIComponent(val);
            if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object') {
                item.e && (nDays.setTime(item.e || nDays.getTime() + Number(item.exp) * 1000), cookieStr += '; expires=' + nDays.toGMTString());
                item.p && (cookieStr += '; path=' + item.p);
                item.d && (cookieStr += '; domain=' + item.d);
            }
            _doc.cookie = cookieStr;
            return cookieStr;
        }
    }, {
        key: '_getCookie',
        value: function _getCookie(key) {
            var arr = [],
                reg = new RegExp("(^| )" + key + "=([^;]*)(;|$)");
            arr = _doc['cookie'].match(reg);
            return arr ? decodeURIComponent(arr[2]) : null;
        }
    }, {
        key: '_delCookie',
        value: function _delCookie(key, item) {
            if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object') this.setCookie(key, '', item);else this.setCookie(key, '', -1, { e: '-1' });
            return key;
        }
    }, {
        key: 'set',
        value: function set() {
            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _checkAndWrapKeyAsString(key);
            var val = arguments[1];
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


            options = _extend({ force: true }, options);
            key = _getRealName(key, this._sign);
            if (val === undefined) return this.delete(key);
            var value = _defaultSerializer.serialize(val);
            var cacheItem = new CacheItemConstructor(value, options);
            if (this.isSupported) {
                try {
                    _storage.setItem(key, _defaultSerializer.serialize(cacheItem));
                } catch (e) {
                    if (_isQuotaExceeded(e)) this._quotaExceedHandler(key, value, options, e);
                }
            } else this._setCookie(key, val, cacheItem);
            return this;
        }
    }, {
        key: 'get',
        value: function get() {
            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _checkAndWrapKeyAsString(key);
            var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


            var cacheItem = null;
            key = _getRealName(key, this._sign);
            if (this.isSupported) {
                try {
                    cacheItem = _defaultSerializer.deserialize(_storage.getItem(key));
                    if (_isCacheItem(cacheItem)) {
                        if (_checkCacheItemIfEffective(cacheItem)) {
                            var value = cacheItem.v;
                            return deep ? _defaultSerializer.deepParse(value) : _defaultSerializer.deserialize(value);
                        } else this.delete(key);
                    } else return null;
                } catch (e) {
                    return null;
                }
            } else return this._getCookie(key);
        }
    }, {
        key: 'delete',
        value: function _delete() {
            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _checkAndWrapKeyAsString(key);

            key = _getRealName(key, this._sign);
            if (this.isSupported) _storage.removeItem(key);else this._delCookie(key);
            return this;
        }
    }, {
        key: 'deleteAll',
        value: function deleteAll() {
            var length = _storage.length;
            var deleteKeys = [];
            var _this = this;
            for (var i = 0; i < length; i++) {
                var key = _storage.key(i);
                var cacheItem = null;
                try {
                    cacheItem = _defaultSerializer.deserialize(_storage.getItem(key));
                } catch (e) {}

                if (cacheItem !== null && cacheItem.e !== undefined) {
                    var timeNow = new Date().getTime();
                    if (timeNow >= cacheItem.e) {
                        deleteKeys.push(key);
                    }
                }
            }
            deleteKeys.forEach(function (key) {
                _this.delete(key);
            });
            return deleteKeys;
        }
    }, {
        key: 'add',
        value: function add() {
            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _checkAndWrapKeyAsString(key);
            var value = arguments[1];
            var options = arguments[2];

            key = _getRealName(key, this._sign);
            options = _extend({ force: true }, options);
            if (this.isSupported) {

                try {
                    var cacheItem = _defaultSerializer.deserialize(_storage.getItem(key));
                    if (!_isCacheItem(cacheItem) || !_checkCacheItemIfEffective(cacheItem)) {
                        this.set(key, value, options);
                        return value;
                    } else {
                        var oldValue = this.get(key);
                        var index = _checkIndexOf(oldValue, value, options.key);

                        if (index == -1) {
                            var newValue = [].concat(value).concat(oldValue);
                            this.set(key, newValue, options);
                            return newValue;
                        } else {
                            var newValues = [].concat(value);
                            var resultValue = void 0;
                            oldValue.splice(index, 1);
                            resultValue = newValues.concat(oldValue);
                            this.set(key, resultValue, options);
                            return resultValue;
                        }
                        return oldValue;
                    }
                } catch (e) {
                    this.set(key, value, options);
                    return value;
                }
            } else {
                var old = this._getCookie(key);
                if (old.indexOf(value) == -1) {
                    var _newValue = [].concat(value).concat(old);
                    this.set(key, _newValue, options);
                    return _newValue;
                }
                return old;
            }
            return null;
        }
    }, {
        key: 'replace',
        value: function replace() {
            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _checkAndWrapKeyAsString(key);
            var ikey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
            var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
            var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

            key = _getRealName(key, this._sign);
            var item = this.get(key);
            var newItem = _removeItem(item, ikey, value, options.key);

            this.set(key, newItem, options);
            return this;
        }
    }, {
        key: 'search',
        value: function search() {
            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _checkAndWrapKeyAsString(key);
            var ikey = arguments[1];

            key = _getRealName(key, this._sign), result = [];
            var list = this.get(key);
            list.forEach(function (v, i) {
                if (v.indexOf(ikey) > -1) result.push(v);
            });
            return result;
        }
    }, {
        key: 'clear',
        value: function clear() {
            _storage.clear();
            return _storage;
        }
    }]);

    return Storage;
}();

;

if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
    return Storage;
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') module.exports = Storage;else _gol.Storage = Storage;

/***/ })
/******/ ]);
});
//# sourceMappingURL=main.js.map